#! /bin/bash
set -ex

THIS_DIR=`realpath $(dirname $0)`
ROOT_DIR=`realpath $THIS_DIR/..`
REPO_NAME=$(basename $ROOT_DIR)

# if PREFIX env is not set, use default value ytn
PREFIX=${PREFIX:-tomqi}
MNT_POINT=${MNT_POINT:-"/mnt/gemininjceph2/geminicephfs/mm-base-plt2/user_$PREFIX"}

HOSTS=($(grep -oP "^Host\\s+${PREFIX}\\d+" ~/.ssh/config | awk '{print $2}'))
PASSWORD="123456wyt"

MASTER_HOST=${HOSTS[0]}

function init_ssh {
# 1. 将本地公钥复制到所有远程主机
echo "步骤1: 将本地公钥复制到所有远程主机..."
for i in "${!HOSTS[@]}"; do
    host=${HOSTS[$i]}
    echo "正在处理 $host ..."

    # 使用expect自动化密码输入
    /usr/bin/expect <<EOF
    spawn ssh-copy-id -o StrictHostKeyChecking=no $host
    expect {
        "*password:*" { send "$PASSWORD\r"; exp_continue }
        eof
    }
EOF

    if [ $? -eq 0 ]; then
        echo "成功将本地公钥复制到 $host"
    else
        echo "错误: 无法将公钥复制到 $host"
        exit 1
    fi
    cat ~/.ssh/config | ssh $host "mkdir -p ~/.ssh && cat > ~/.ssh/config && chmod 600 ~/.ssh/config"
done


# 2. 在0号机器上生成密钥并复制到其他主机
echo "步骤2: 在0号机器($MASTER_HOST)上生成新密钥并复制到其他主机..."

# 生成密钥（如果不存在）
ssh "$MASTER_HOST" << EOF
    if [ ! -f ~/.ssh/id_rsa ]; then
        echo -e "\n\n\n" | ssh-keygen -t rsa -N ""
        echo "在$MASTER_HOST上生成新SSH密钥"
    else
        echo "$MASTER_HOST上已存在SSH密钥 跳过生成"
    fi
EOF

# 获取0号机器的公钥
MASTER_PUBKEY=$(ssh "$MASTER_HOST" "cat ~/.ssh/id_rsa.pub")

# 复制到其他主机
for i in "${!HOSTS[@]}"; do
    host=${HOSTS[$i]}
    echo "正在将$MASTER_HOST的公钥复制到$host..."

    # 使用expect添加公钥
    /usr/bin/expect <<EOF
    spawn ssh $host "mkdir -p ~/.ssh; echo \"$MASTER_PUBKEY\" >> ~/.ssh/authorized_keys; chmod 700 ~/.ssh; chmod 600 ~/.ssh/authorized_keys"
    expect {
        "*password:*" { send "$PASSWORD\r"; exp_continue }
        eof
    }
EOF

    if [ $? -eq 0 ]; then
        echo "成功将$MASTER_HOST的公钥复制到$host"
    else
        echo "错误: 无法将公钥复制到$host"
        exit 1
    fi
done

# setup hosts on every remote host. ytnX -> the coressponding IP in ~/.ssh/config
# 4. 在每个远程主机上设置hosts文件，将ytnX映射到对应的IP
echo "步骤4: 在每个远程主机上设置hosts文件..."

# 从~/.ssh/config中提取所有主机名和IP的映射
declare -A HOST_MAP
while read -r line; do
    if [[ $line =~ ^Host\ ([a-zA-Z0-9-]+)$ ]]; then
        current_host=${BASH_REMATCH[1]}
    elif [[ $line =~ ^Hostname\ ([0-9.]+)$ ]]; then
        HOST_MAP[$current_host]=${BASH_REMATCH[1]}
    fi
done < ~/.ssh/config

# 为每个主机生成hosts文件内容
HOSTS_CONTENT="# Auto-generated by setup script\n"
for host in "${!HOST_MAP[@]}"; do
    if [[ $host == ${PREFIX}* ]]; then  # 只处理以PREFIX开头的主机
        HOSTS_CONTENT+="${HOST_MAP[$host]} $host\n"
    fi
done


echo -e "以下是将要添加到每个远程主机/etc/hosts文件中的内容:\n$HOSTS_CONTENT"


# 并行更新所有主机的/etc/hosts文件
echo "开始并行更新所有主机的/etc/hosts文件..."

# 创建临时目录存储结果
tmpdir=$(mktemp -d)
trap 'rm -rf "$tmpdir"' EXIT

# 定义更新函数
update_hosts_file() {
    local host=$1
    local status_file="$tmpdir/${host}.status"

    echo "正在更新 $host 的/etc/hosts文件..." | tee "$status_file"

    # 备份原始hosts文件
    if ! ssh "$host" "cp /etc/hosts /etc/hosts.bak"; then
        echo "错误: 无法备份 $host 的/etc/hosts文件" | tee -a "$status_file"
        return 1
    fi

    # 执行更新操作
    ssh "$host" "
        # 步骤1: 保留非${PREFIX}开头的行
        grep -v \"${PREFIX}[0-9]\" /etc/hosts > /tmp/hosts.tmp || exit 1

        # 步骤2: 清空原文件
        if ! truncate -s 0 /etc/hosts 2>/dev/null; then
            echo -n > /etc/hosts || exit 1
        fi

        # 步骤3: 写回保留的内容
        cat /tmp/hosts.tmp >> /etc/hosts || exit 1

        # 步骤4: 追加新条目
        echo -e '$HOSTS_CONTENT' >> /etc/hosts || exit 1

        # 清理临时文件
        rm -f /tmp/hosts.tmp
    " 2>&1 | tee -a "$status_file"

    if [ ${PIPESTATUS[0]} -eq 0 ]; then
        echo "成功更新 $host 的/etc/hosts文件" | tee -a "$status_file"
        echo "更新后的hosts文件内容:" | tee -a "$status_file"
        ssh "$host" "grep '${PREFIX}[0-9]' /etc/hosts" 2>&1 | tee -a "$status_file"
        return 0
    else
        echo "错误: 无法更新 $host 的/etc/hosts文件" | tee -a "$status_file"
        return 1
    fi
}

# 并行执行更新
for i in "${!HOSTS[@]}"; do
    host=${HOSTS[$i]}
    update_hosts_file "$host" > "$tmpdir/${host}.log" 2>&1 &
done

# 等待所有后台任务完成
wait

# 检查结果并输出
failed=0
for host in "${HOSTS[@]}"; do
    echo -e "\n===== $host 更新结果 ====="
    cat "$tmpdir/${host}.log"

    if grep -q "错误" "$tmpdir/${host}.log"; then
        failed=1
    fi
done

if [ $failed -eq 1 ]; then
    echo -e "\n错误: 部分主机更新失败"
    exit 1
else
    echo -e "\n所有主机的/etc/hosts文件更新成功"
fi

echo "所有远程主机的hosts文件已成功更新"

# 5. 并行验证主机名解析
echo "步骤5: 并行验证主机名解析..."

# 创建临时目录存储结果
tmpdir=$(mktemp -d)
trap 'rm -rf "$tmpdir"' EXIT

# 定义验证函数
validate_resolution() {
    local host=$1
    local target_host=$2
    local expected_ip=${HOST_MAP[$target_host]}

    echo -n "在 $host 上解析 $target_host: "
    resolved_ip=$(ssh "$host" "getent hosts $target_host | awk '{print \$1}'" 2>/dev/null)

    if [ "$resolved_ip" == "$expected_ip" ]; then
        echo "成功 - $resolved_ip"
        return 0
    else
        echo "失败 (期望: $expected_ip, 实际: $resolved_ip)"
        return 1
    fi
}

# 并行执行验证
for i in "${!HOSTS[@]}"; do
    host=${HOSTS[$i]}
    for target_host in "${HOSTS[@]}"; do
        if [ "$host" != "$target_host" ]; then
            validate_resolution "$host" "$target_host" > "$tmpdir/${host}_${target_host}.log" 2>&1 &
        fi
    done
done

# 等待所有后台任务完成
wait

# 检查是否有失败
failed=0
for logfile in "$tmpdir"/*.log; do
    if grep -q "失败" "$logfile"; then
        cat "$logfile"
        failed=1
    fi
done

if [ $failed -eq 1 ]; then
    echo "错误: 部分主机名解析验证失败"
    exit 1
else
    echo "所有主机名解析验证成功"
fi

}

function init_local {

for i in "${!HOSTS[@]}"; do
    host=${HOSTS[$i]}
    echo "local-initialize $host ..."
    env_str=''
    if [ -n "$REINSTALL_NIXL_ONLY" ]; then
        env_str="REINSTALL_NIXL_ONLY=1"
    elif [ -n "$SKIP_APT" ]; then
        env_str="SKIP_APT=1"
    fi
    ssh "$host" "cd $MNT_POINT/$REPO_NAME/.setup && ${env_str} PREFIX=$PREFIX MNT_POINT=$MNT_POINT bash local-initialize-ceph.sh >/tmp/init.log 2>&1" &
done
wait

}

cmd=$1
shift

case $cmd in
"ssh")
    init_ssh
    ;;
"local")
    init_local
    ;;
*)
    echo "Usage: $0 {ssh|local}"
    exit 1
    ;;
esac
